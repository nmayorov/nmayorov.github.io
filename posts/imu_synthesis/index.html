<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Strapdown IMU synthesis | Navigating Uncertainty</title>
<meta name=keywords content><meta name=description content="Synthesis of strapdown Inertial Measurement Unit (IMU) readings is required for simulation of inertial navigation systems and related algorithms development. Here I want to describe the algorithm of IMU synthesis implemented in pyins, which is probably one of the most useful functions in the library.
Problem formulation The task is to compute strapdown IMU readings from a time series of position and attitude. The following points define the algorithm requirements:"><meta name=author content="Nikolay Mayorov"><link rel=canonical href=https://nmayorov.github.io/posts/imu_synthesis/><link crossorigin=anonymous href=/assets/css/stylesheet.a801c217e3c96db9c9df36cb1d2216a9bc5d9fa77b72e2afcdf47fb847f8f015.css integrity="sha256-qAHCF+PJbbnJ3zbLHSIWqbxdn6d7cuKvzfR/uEf48BU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://nmayorov.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nmayorov.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nmayorov.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://nmayorov.github.io/apple-touch-icon.png><link rel=mask-icon href=https://nmayorov.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nmayorov.github.io/posts/imu_synthesis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script><meta property="og:title" content="Strapdown IMU synthesis"><meta property="og:description" content="Synthesis of strapdown Inertial Measurement Unit (IMU) readings is required for simulation of inertial navigation systems and related algorithms development. Here I want to describe the algorithm of IMU synthesis implemented in pyins, which is probably one of the most useful functions in the library.
Problem formulation The task is to compute strapdown IMU readings from a time series of position and attitude. The following points define the algorithm requirements:"><meta property="og:type" content="article"><meta property="og:url" content="https://nmayorov.github.io/posts/imu_synthesis/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Strapdown IMU synthesis"><meta name=twitter:description content="Synthesis of strapdown Inertial Measurement Unit (IMU) readings is required for simulation of inertial navigation systems and related algorithms development. Here I want to describe the algorithm of IMU synthesis implemented in pyins, which is probably one of the most useful functions in the library.
Problem formulation The task is to compute strapdown IMU readings from a time series of position and attitude. The following points define the algorithm requirements:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nmayorov.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Strapdown IMU synthesis","item":"https://nmayorov.github.io/posts/imu_synthesis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Strapdown IMU synthesis","name":"Strapdown IMU synthesis","description":"Synthesis of strapdown Inertial Measurement Unit (IMU) readings is required for simulation of inertial navigation systems and related algorithms development. Here I want to describe the algorithm of IMU synthesis implemented in pyins, which is probably one of the most useful functions in the library.\nProblem formulation The task is to compute strapdown IMU readings from a time series of position and attitude. The following points define the algorithm requirements:","keywords":[],"articleBody":"Synthesis of strapdown Inertial Measurement Unit (IMU) readings is required for simulation of inertial navigation systems and related algorithms development. Here I want to describe the algorithm of IMU synthesis implemented in pyins, which is probably one of the most useful functions in the library.\nProblem formulation The task is to compute strapdown IMU readings from a time series of position and attitude. The following points define the algorithm requirements:\nData is provided at known time points $t_k$, not necessary equispaced Position is given as a time series of latitude, longitude and altitude – $\\varphi(t_k), \\lambda(t_k), h(t_k)$ Attitude is given as a time series of roll, pitch and heading angles – $\\gamma(t_k), \\theta(t_k), \\psi(t_k)$ The algorithm must account for Earth rotation and ellipticity and use realistic gravity model The algorithm must be able to compute rate and increment (integral) readings Preliminarily considerations We want to generate IMU from sampled trajectory points instead of some predefined continuous functions to have more flexibility and convenience. Figuring out and implementing appropriate continuous functions for position and attitude is difficult task on its own, which is better to be avoided.\nWith sampled trajectory points it is obvious that formally the derivatives and thus IMU readings can be arbitrary, i.e. the function might exhibit erratic behavior still passing through sampled points. The key and necessary assumption here is that the underlying function is bandlimited and sampled with sufficient frequency (formally more frequent than Nyquist frequency if time points are equispaced). Frequency domain approaches might in fact be the most appropriate and insightful, but the fact that rotations belong to a non-euclidean space (SO(3) manifold) complicates things significantly.\nInstead, the proposed algorithm relies on cubic spline interpolation, which provides twice differentiable functions. In my understanding it works as some kind of approximation of Shannon’s optimal interpolation (sinc interpolation).\nAnother known approach to generate IMU is to invert a high accuracy strapdown integration algorithm. I find this approach conceptually not satisfactory as quite complicated, coupled with the integration scheme and not clear in terms of properties of the resulting IMU readings.\nNow leaving aside somewhat vague conceptual speculations let’s move to the actual algorithm.\nAlgorithm derivation Coordinate frames, navigation definitions and equations are explained here.\nDefinition of IMU readings First let’s define precisely what IMU measures.\nAccelerometers measure “specific force”, i.e. total force excluding gravity, computed for a unit mass as acceleration: $$ f^b = C^b_i (\\ddot{r}^i - g_i^i) $$ Where $r^i$ is the body position relative to ECI frame, twice differentiated to get the true inertial acceleration. And $g_i^i$ is acceleration due to Earth mass attraction, not including the centrifugal force.\nGyroscopes measure angular rate around its axes relative to the inertial frame – $\\omega_{ib}^b$.\nThe rate IMU readings are then $f^b(t_k)$ and $\\omega_{ib}^b(t_k)$. The increment IMU readings are defined as integrals: $$ \\upsilon(t_k) = \\int_{t_{k - 1}}^{t_k} f^b(t) d t \\\\ \\alpha(t_k) = \\int_{t_{k - 1}}^{t_k} \\omega_{ib}^b(t) d t $$\nBuilding interpolation splines First we compute “inertial longitude” to account for Earth rotation: $$ \\lambda_i(t_k) = \\lambda(t_k) + \\omega_e t_k $$ And then compute position and attitude relative to ECI: $$ r^i(t_k) = r^i(\\varphi(t_k), \\lambda_i(t_k), h(t_k)) \\\\ C^i_b(t_k) = C^i_n(\\varphi(t_k), \\lambda_i(t_k)) C^n_b(\\gamma(t_k), \\theta(t_k), \\psi(t_k)) $$ All the involved variables are computed as known functions of the inputs.\nFor $r^i$ and $C^i_n$ we then build cubic interpolation splines, which in scipy are implemented as CubicSpline and RotationSpline respectively. Specific boundary conditions for CubicSpline don’t seem to be very important, default conditions are used in pyins. Note that RotationSpline interpolates rotations with continuous angular rate and acceleration and does a lot of heavy lifting inside.\nLet’s formally denote these splines as $S_p$ and $S_a$ respectively.\nComputing rate readings Rate readings are trivially computed from the splines: $$ f^b(t_k) = C^b_i(t_k) (\\ddot{S}_p(t_k) - g_i^i(\\varphi(t_k), \\lambda_i(t_k), h(t_k))) \\\\ \\omega_{ib}^b(t_k) = \\dot{S}_a(t_k) $$ Here $g_i^i$ is computed as known function of latitude, inertial longitude and altitude and the derivative of $S_a$ is assumed to give the angular rate.\nComputing incremental readings Computation of incremental readings is more difficult because of two facts:\nCoefficients of RotationSpline define a rotation vector, but the angular velocity is a nonlinear function of the vector and its derivative Computation of the specific force in the body frame couples rotation and position splines, moreover the rotation transform is a nonlinear function of the rotation vector Both of these difficulties can be resolved analytically with the assumption that the rotation vector on each interval is small. Note that if this is not true, then IMU readings are almost useless for navigation anyway.\nWe use a second-order (in the norm of the rotation vector $\\theta_k$) approximations: $$ C^i_{bk}(\\tau) \\approx C^i_b(t_{k - 1}) \\left(I + (\\theta_k(\\tau) \\times) + \\frac{1}{2} (\\theta_k(\\tau) \\times)^2 \\right) \\\\ \\omega_{ibk}^b(\\tau) \\approx \\left(I - \\dfrac{1}{2} (\\theta_k(\\tau) \\times) + \\frac{1}{6} (\\theta_k(\\tau) \\times)^2 \\right) \\dot{\\theta}_k(\\tau) \\\\ \\text{ with } \\tau = t - t_{k - 1} \\text{ and } t_{k - 1} \\leq t \u003c t_k \\\\ $$\nGyro readings The rotation vector at $k$-th interval is expressed as a cubic function of the time offset (with coefficients available in RotationSpline): $$ \\theta_k(\\tau) = a_k \\tau + b_k \\tau^2 + c_k \\tau^3 $$ Substituting this into the approximate formula for the angular rate we get a 7-th order power series in $\\tau$. The coefficients in this power series contain the spline coefficients, their single and double cross-products. The cross-products can be attributed to so-called rotation “coning” effects. It then integrated from 0 to $t_k - t_{k - 1}$ to get $\\alpha(t_k)$.\nAccelerometer readings A linear model for the specific force in the inertial frame is built by twice differentiating $S_p$ and using piecewise-linear interpolation for $g_i^i$ (it changes slowly with coordinates): $$ f_k^i(\\tau) = d^i_k + e^i_k \\tau $$ Specific force in the body frame is then: $$ \\begin{split} f_k^b(\\tau) = C^b_{ik}(\\tau) f_k^i(\\tau) \\approx \\left(I - (\\theta_k(\\tau) \\times) + \\frac{1}{2} (\\theta_k(\\tau) \\times)^2 \\right) C^b_i(t_{k - 1}) (d^i_k + e^i_k \\tau) = \\\\ = \\left(I - (\\theta_k(\\tau) \\times) + \\frac{1}{2} (\\theta_k(\\tau) \\times)^2 \\right) (d_k + e_k \\tau) \\end{split} $$ Where the projected coefficients were defined: $$ d_k \\coloneqq C^b_i(t_{k - 1}) d^i_k \\\\ e_k \\coloneqq C^b_i(t_{k - 1}) e^i_k $$ Substituting $\\theta_k(\\tau)$ we get another 7-th order power series in $\\tau$ (with different cross-products attributed to “sculling” effects). It then integrated from 0 to $t_k - t_{k - 1}$ to get $\\upsilon(t_k)$.\nThe coefficients of the aforementioned series can be found in pyins.sim source file.\nPractical considerations and discussion From the experience, the implemented method does require more or less smooth input trajectory. Typically, the required level of smoothing is determined empirically by checking if generated readings have adequate magnitude and whether they give an accurate trajectory after the integration. The example illustrates this point.\nHow to characterize or decrease this “noise amplification”, what is the required ratio between sampling and motion frequency – it requires investigation, perhaps digging into frequency domain properties of spline interpolation.\n","wordCount":"1147","inLanguage":"en","datePublished":"2024-03-03T00:00:00Z","dateModified":"2024-03-03T00:00:00Z","author":{"@type":"Person","name":"Nikolay Mayorov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nmayorov.github.io/posts/imu_synthesis/"},"publisher":{"@type":"Organization","name":"Navigating Uncertainty","logo":{"@type":"ImageObject","url":"https://nmayorov.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nmayorov.github.io/ accesskey=h title="Navigating Uncertainty (Alt + H)">Navigating Uncertainty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://nmayorov.github.io/open_source title="Open source"><span>Open source</span></a></li><li><a href=https://nmayorov.github.io/archives title="All posts"><span>All posts</span></a></li><li><a href=https://nmayorov.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://nmayorov.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://nmayorov.github.io/posts/>Posts</a></div><h1 class=post-title>Strapdown IMU synthesis</h1><div class=post-meta><span title='2024-03-03 00:00:00 +0000 UTC'>March 3, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Nikolay Mayorov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#problem-formulation aria-label="Problem formulation">Problem formulation</a></li><li><a href=#preliminarily-considerations aria-label="Preliminarily considerations">Preliminarily considerations</a></li><li><a href=#algorithm-derivation aria-label="Algorithm derivation">Algorithm derivation</a><ul><li><a href=#definition-of-imu-readings aria-label="Definition of IMU readings">Definition of IMU readings</a></li><li><a href=#building-interpolation-splines aria-label="Building interpolation splines">Building interpolation splines</a></li><li><a href=#computing-rate-readings aria-label="Computing rate readings">Computing rate readings</a></li><li><a href=#computing-incremental-readings aria-label="Computing incremental readings">Computing incremental readings</a><ul><li><a href=#gyro-readings aria-label="Gyro readings">Gyro readings</a></li><li><a href=#accelerometer-readings aria-label="Accelerometer readings">Accelerometer readings</a></li></ul></li></ul></li><li><a href=#practical-considerations-and-discussion aria-label="Practical considerations and discussion">Practical considerations and discussion</a></li></ul></div></details></div><div class=post-content><p>Synthesis of strapdown Inertial Measurement Unit (IMU) readings is required for simulation of inertial navigation systems and related algorithms development.
Here I want to describe the algorithm of IMU synthesis implemented in <a href=github.com/nmayorov/pyins>pyins</a>, which is probably one of the most useful functions in the library.</p><h1 id=problem-formulation>Problem formulation<a hidden class=anchor aria-hidden=true href=#problem-formulation>#</a></h1><p>The task is to compute strapdown IMU readings from a time series of position and attitude.
The following points define the algorithm requirements:</p><ul><li>Data is provided at known time points $t_k$, not necessary equispaced</li><li>Position is given as a time series of latitude, longitude and altitude &ndash; $\varphi(t_k), \lambda(t_k), h(t_k)$</li><li>Attitude is given as a time series of roll, pitch and heading angles &ndash; $\gamma(t_k), \theta(t_k), \psi(t_k)$</li><li>The algorithm must account for Earth rotation and ellipticity and use realistic gravity model</li><li>The algorithm must be able to compute rate and increment (integral) readings</li></ul><h1 id=preliminarily-considerations>Preliminarily considerations<a hidden class=anchor aria-hidden=true href=#preliminarily-considerations>#</a></h1><p>We want to generate IMU from sampled trajectory points instead of some predefined continuous functions to have more flexibility and convenience.
Figuring out and implementing appropriate continuous functions for position and attitude is difficult task on its own, which is better to be avoided.</p><p>With sampled trajectory points it is obvious that formally the derivatives and thus IMU readings can be arbitrary, i.e. the function might exhibit erratic behavior still passing through sampled points.
The key and necessary assumption here is that the underlying function is <em>bandlimited</em> and sampled with sufficient frequency (formally more frequent than Nyquist frequency if time points are equispaced).
Frequency domain approaches might in fact be the most appropriate and insightful, but the fact that rotations belong to a non-euclidean space (SO(3) manifold) complicates things significantly.</p><p>Instead, the proposed algorithm relies on cubic spline interpolation, which provides twice differentiable functions.
In my understanding it works as some kind of approximation of Shannon&rsquo;s optimal interpolation (sinc interpolation).</p><p>Another known approach to generate IMU is to invert a high accuracy strapdown integration algorithm.
I find this approach conceptually not satisfactory as quite complicated, coupled with the integration scheme and not clear in terms of properties of the resulting IMU readings.</p><p>Now leaving aside somewhat vague conceptual speculations let&rsquo;s move to the actual algorithm.</p><h1 id=algorithm-derivation>Algorithm derivation<a hidden class=anchor aria-hidden=true href=#algorithm-derivation>#</a></h1><p>Coordinate frames, navigation definitions and equations are explained <a href=https://nmayorov.github.io/posts/ins_error_equations/>here</a>.</p><h2 id=definition-of-imu-readings>Definition of IMU readings<a hidden class=anchor aria-hidden=true href=#definition-of-imu-readings>#</a></h2><p>First let&rsquo;s define precisely what IMU measures.</p><p>Accelerometers measure &ldquo;specific force&rdquo;, i.e. total force excluding gravity, computed for a unit mass as acceleration:
$$
f^b = C^b_i (\ddot{r}^i - g_i^i)
$$
Where $r^i$ is the body position relative to ECI frame, twice differentiated to get the true inertial acceleration.
And $g_i^i$ is acceleration due to Earth mass attraction, not including the centrifugal force.</p><p>Gyroscopes measure angular rate around its axes relative to the inertial frame &ndash; $\omega_{ib}^b$.</p><p>The rate IMU readings are then $f^b(t_k)$ and $\omega_{ib}^b(t_k)$.
The increment IMU readings are defined as integrals:
$$
\upsilon(t_k) = \int_{t_{k - 1}}^{t_k} f^b(t) d t \\
\alpha(t_k) = \int_{t_{k - 1}}^{t_k} \omega_{ib}^b(t) d t
$$</p><h2 id=building-interpolation-splines>Building interpolation splines<a hidden class=anchor aria-hidden=true href=#building-interpolation-splines>#</a></h2><p>First we compute &ldquo;inertial longitude&rdquo; to account for Earth rotation:
$$
\lambda_i(t_k) = \lambda(t_k) + \omega_e t_k
$$
And then compute position and attitude relative to ECI:
$$
r^i(t_k) = r^i(\varphi(t_k), \lambda_i(t_k), h(t_k)) \\
C^i_b(t_k) = C^i_n(\varphi(t_k), \lambda_i(t_k)) C^n_b(\gamma(t_k), \theta(t_k), \psi(t_k))
$$
All the involved variables are computed as known functions of the inputs.</p><p>For $r^i$ and $C^i_n$ we then build cubic interpolation splines, which in <code>scipy</code> are implemented as <code>CubicSpline</code> and <code>RotationSpline</code> respectively.
Specific boundary conditions for <code>CubicSpline</code> don&rsquo;t seem to be very important, default conditions are used in <code>pyins</code>.
Note that <code>RotationSpline</code> interpolates rotations with continuous angular rate and acceleration and does a lot of heavy lifting inside.</p><p>Let&rsquo;s formally denote these splines as $S_p$ and $S_a$ respectively.</p><h2 id=computing-rate-readings>Computing rate readings<a hidden class=anchor aria-hidden=true href=#computing-rate-readings>#</a></h2><p>Rate readings are trivially computed from the splines:
$$
f^b(t_k) = C^b_i(t_k) (\ddot{S}_p(t_k) - g_i^i(\varphi(t_k), \lambda_i(t_k), h(t_k))) \\
\omega_{ib}^b(t_k) = \dot{S}_a(t_k)
$$
Here $g_i^i$ is computed as known function of latitude, inertial longitude and altitude and the derivative of $S_a$ is assumed to give the angular rate.</p><h2 id=computing-incremental-readings>Computing incremental readings<a hidden class=anchor aria-hidden=true href=#computing-incremental-readings>#</a></h2><p>Computation of incremental readings is more difficult because of two facts:</p><ul><li>Coefficients of <code>RotationSpline</code> define a rotation vector, but the angular velocity is a nonlinear function of the vector and its derivative</li><li>Computation of the specific force in the body frame couples rotation and position splines, moreover the rotation transform is a nonlinear function of the rotation vector</li></ul><p>Both of these difficulties can be resolved analytically with the assumption that the rotation vector on each interval is small.
Note that if this is not true, then IMU readings are almost useless for navigation anyway.</p><p>We use a second-order (in the norm of the rotation vector $\theta_k$) approximations:
$$
C^i_{bk}(\tau) \approx C^i_b(t_{k - 1}) \left(I + (\theta_k(\tau) \times) + \frac{1}{2} (\theta_k(\tau) \times)^2 \right) \\
\omega_{ibk}^b(\tau) \approx \left(I - \dfrac{1}{2} (\theta_k(\tau) \times) + \frac{1}{6} (\theta_k(\tau) \times)^2 \right) \dot{\theta}_k(\tau) \\
\text{ with } \tau = t - t_{k - 1} \text{ and } t_{k - 1} \leq t &lt; t_k \\
$$</p><h3 id=gyro-readings>Gyro readings<a hidden class=anchor aria-hidden=true href=#gyro-readings>#</a></h3><p>The rotation vector at $k$-th interval is expressed as a cubic function of the time offset (with coefficients available in <code>RotationSpline</code>):
$$
\theta_k(\tau) = a_k \tau + b_k \tau^2 + c_k \tau^3
$$
Substituting this into the approximate formula for the angular rate we get a 7-th order power series in $\tau$.
The coefficients in this power series contain the spline coefficients, their single and double cross-products.
The cross-products can be attributed to so-called rotation &ldquo;coning&rdquo; effects.
It then integrated from 0 to $t_k - t_{k - 1}$ to get $\alpha(t_k)$.</p><h3 id=accelerometer-readings>Accelerometer readings<a hidden class=anchor aria-hidden=true href=#accelerometer-readings>#</a></h3><p>A linear model for the specific force in the inertial frame is built by twice differentiating $S_p$ and using piecewise-linear interpolation for $g_i^i$ (it changes slowly with coordinates):
$$
f_k^i(\tau) = d^i_k + e^i_k \tau
$$
Specific force in the body frame is then:
$$
\begin{split}
f_k^b(\tau) = C^b_{ik}(\tau) f_k^i(\tau) \approx \left(I - (\theta_k(\tau) \times) + \frac{1}{2} (\theta_k(\tau) \times)^2 \right) C^b_i(t_{k - 1}) (d^i_k + e^i_k \tau) = \\
= \left(I - (\theta_k(\tau) \times) + \frac{1}{2} (\theta_k(\tau) \times)^2 \right) (d_k + e_k \tau)
\end{split}
$$
Where the projected coefficients were defined:
$$
d_k \coloneqq C^b_i(t_{k - 1}) d^i_k \\
e_k \coloneqq C^b_i(t_{k - 1}) e^i_k
$$
Substituting $\theta_k(\tau)$ we get another 7-th order power series in $\tau$ (with different cross-products attributed to &ldquo;sculling&rdquo; effects).
It then integrated from 0 to $t_k - t_{k - 1}$ to get $\upsilon(t_k)$.</p><p>The coefficients of the aforementioned series can be found in <a href=https://github.com/nmayorov/pyins/blob/master/pyins/sim.py>pyins.sim</a> source file.</p><h1 id=practical-considerations-and-discussion>Practical considerations and discussion<a hidden class=anchor aria-hidden=true href=#practical-considerations-and-discussion>#</a></h1><p>From the experience, the implemented method does require more or less smooth input trajectory.
Typically, the required level of smoothing is determined empirically by checking if generated readings have adequate magnitude and whether they give an accurate trajectory after the integration.
The <a href=https://github.com/nmayorov/pyins/blob/master/examples/ideal_imu.ipynb>example</a> illustrates this point.</p><p>How to characterize or decrease this &ldquo;noise amplification&rdquo;, what is the required ratio between sampling and motion frequency &ndash; it requires investigation, perhaps digging into frequency domain properties of spline interpolation.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://nmayorov.github.io/>Navigating Uncertainty</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>