<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementation of Kalman correction formulas | Navigating Uncertainty</title>
<meta name=keywords content><meta name=description content="This is a short note on my view how to best implement Kalman correction formulas in a programing language.
Basic formulas A vector measurement is linearly related to a state vector with an additive noise: $$ z = H x + v $$ Where $z$ and $H$ are a known vector and matrix and the noise vector $v$ has a known covariance matrix $R$. Thus the measurement model is defined by 3 elements &ndash; $z, H, R$."><meta name=author content="Nikolay Mayorov"><link rel=canonical href=https://nmayorov.github.io/posts/practical_kalman_correction/><link crossorigin=anonymous href=/assets/css/stylesheet.a801c217e3c96db9c9df36cb1d2216a9bc5d9fa77b72e2afcdf47fb847f8f015.css integrity="sha256-qAHCF+PJbbnJ3zbLHSIWqbxdn6d7cuKvzfR/uEf48BU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://nmayorov.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nmayorov.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nmayorov.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://nmayorov.github.io/apple-touch-icon.png><link rel=mask-icon href=https://nmayorov.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://nmayorov.github.io/posts/practical_kalman_correction/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script><meta property="og:title" content="Implementation of Kalman correction formulas"><meta property="og:description" content="This is a short note on my view how to best implement Kalman correction formulas in a programing language.
Basic formulas A vector measurement is linearly related to a state vector with an additive noise: $$ z = H x + v $$ Where $z$ and $H$ are a known vector and matrix and the noise vector $v$ has a known covariance matrix $R$. Thus the measurement model is defined by 3 elements &ndash; $z, H, R$."><meta property="og:type" content="article"><meta property="og:url" content="https://nmayorov.github.io/posts/practical_kalman_correction/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementation of Kalman correction formulas"><meta name=twitter:description content="This is a short note on my view how to best implement Kalman correction formulas in a programing language.
Basic formulas A vector measurement is linearly related to a state vector with an additive noise: $$ z = H x + v $$ Where $z$ and $H$ are a known vector and matrix and the noise vector $v$ has a known covariance matrix $R$. Thus the measurement model is defined by 3 elements &ndash; $z, H, R$."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nmayorov.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Implementation of Kalman correction formulas","item":"https://nmayorov.github.io/posts/practical_kalman_correction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implementation of Kalman correction formulas","name":"Implementation of Kalman correction formulas","description":"This is a short note on my view how to best implement Kalman correction formulas in a programing language.\nBasic formulas A vector measurement is linearly related to a state vector with an additive noise: $$ z = H x + v $$ Where $z$ and $H$ are a known vector and matrix and the noise vector $v$ has a known covariance matrix $R$. Thus the measurement model is defined by 3 elements \u0026ndash; $z, H, R$.","keywords":[],"articleBody":"This is a short note on my view how to best implement Kalman correction formulas in a programing language.\nBasic formulas A vector measurement is linearly related to a state vector with an additive noise: $$ z = H x + v $$ Where $z$ and $H$ are a known vector and matrix and the noise vector $v$ has a known covariance matrix $R$. Thus the measurement model is defined by 3 elements – $z, H, R$.\nThe measurement is processed to improve the state estimate and reduce its error variance according to formulas: $$ x^+ = x^- + K (z - H x^-) \\\\ P^+ = (I - KH) P^- \\\\ \\text{with } K = P^- H^T S^{-1} \\text{ and } S = H P^- H^T + R $$ Where $x^-, P^-$ and $x^+, P^+$ are state estimates and error covariance matrices before (aprior) and after (aposteriori) the measurement was processed respectively. The gain vector $K$ optimally combines the apriori estimate and the measurement to achieve the smallest error variance of the $x^+$.\nThe formulas are valid as long as the innovation covariance matrix $S$ is positive definite, which makes them almost universally applicable in practical problems.\nScalar measurement If $z$ contains only a single element we can consider it to be a scalar and write the measurement equation as $$ z = h^T x + v $$ Let $r$ be the variance of the scalar noise $v$.\nThe correction formulas are more simple and elegant in this case: $$ x^+ = x^- + (z - h^T x^-) k \\\\ P^+ = P^- - s k k^T \\\\ \\text{with } k = P^- h / s \\space \\text{ and } \\space s = h^T P^- h + r $$ Its free from the matrix inversion as we have the scalar innovation variance $s$.\nThe covariance formula has a nice symmetric rank-1 update form. This operation is known as SYR BLAS subroutine. For example in Eigen C++ library it is provided by the method SelfAdjointView::rankUpdate. It is recommended to use a similar method of function in your implementation if possible.\nIndependent measurements and sequential updates Consider a measurement vector composed of two independent (uncorrelated) blocks: $$ z = \\begin{bmatrix} z_1 \\\\ z_2 \\end{bmatrix} \\\\ H = \\begin{bmatrix} H_1 \\\\ H_2 \\end{bmatrix} \\\\ R = \\begin{bmatrix} R_1 \u0026 0 \\\\ 0 \u0026 R_2 \\end{bmatrix} $$ The matrix $R$ is block diagonal which represents the aforementioned independence.\nFrom probabilistic and logical reasoning we can conclude that processing measurement $z$ is equivalent to processing measurements $z_1$ and $z_2$ sequentially in any order. Surprisingly it’s hard to prove that using formal matrix transformations of the correction formulas. I haven’t been able to find a simple approach to that.\nA proof can be given using the equivalent «inverse covariance» form of the correction formulas: $$ (P^+)^{-1} x^+ = (P^-)^{-1} x^- + H^T R^{-1} z \\\\ (P^+)^{-1} = (P^-)^{-1} + H^T R^{-1} H $$ They are more restrictive compared to the standard formulas as requiring positive definite $P$ and $R$ matrices.\nSubstituting the composed measurement matrices into it we get $$ (P^+)^{-1} x^+ = (P^-)^{-1} x^- + H_1^T R_1^{-1} z_1 + H_2^T R_2^{-1} z_2 \\\\ (P^+)^{-1} = (P^-)^{-1} + H_1^T R_1^{-1} H_1 + H_2^T R_2^{-1} H_2 $$ We see that these formulas are additive in the measurement blocks and thus the sequential processing is correct.\nIf $R$ and $P$ are not positive definite we can consider an artificial positive diagonal regularization, do the sequential processing in the standard form and then set the regularization to zero (in a limit sense). This is an informal proof that the sequential processing is correct as long as the standard formulas are applicable.\nMeasurements with diagonal $R$ If the matrix $R$ is diagonal then all individual measurement components are independent. Such measurement are processed as a sequence of scalar measurements $z_i, h_i, r_i$ with $$ h_i = (H_{i, :})^T \\\\ r_i = R_{i, i} $$ where $H_{i, :}$ is the $i$-th row of $H$.\nMeasurements with non-diagonal $R$ We can apply the sequential measurement processing in this case too by introducing an augmented vector: $$ x_a = \\begin{bmatrix} x \\\\ v \\end{bmatrix} $$\nThe apriori state estimate and covariance matrix for the augmented vector are: $$ x_a^- = \\begin{bmatrix} x^- \\\\ 0 \\end{bmatrix} \\\\ P_a^- = \\begin{bmatrix} P^- \u0026 0 \\\\ 0 \u0026 R \\end{bmatrix} $$\nThe measurement in terms of the augmented vector: $$ z = H x + v = H_a x_a + v_a \\\\ \\text{with } H_a = \\begin{bmatrix} H \u0026 I \\end{bmatrix} $$ The dummy noise vector $v_a$ has zero covariance matrix $R_a = 0$.\nThen the augmented measurement model $z, H_a, R_a$ is processed for $x_a^-, P_a^-$ using the sequential approach to get $x_a^+, P_a^+$. The head of $x_a^+$ and the top-left corner of $P_a^+$ contain the required aposteriori $x^+$ and $P^+$.\nOverall algorithm The following algorithm can be used to process an arbitrary measurement model $z, H, R$:\nIf $R$ is diagonal: apply the sequential processing to the original model If $R$ is not diagonal: build the augmented model and apply the sequential processing to it The core algorithm in both cases is the scalar measurement processing described above, which is easy to implement and robust.\n","wordCount":"872","inLanguage":"en","datePublished":"2023-01-12T00:00:00Z","dateModified":"2023-01-12T00:00:00Z","author":{"@type":"Person","name":"Nikolay Mayorov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nmayorov.github.io/posts/practical_kalman_correction/"},"publisher":{"@type":"Organization","name":"Navigating Uncertainty","logo":{"@type":"ImageObject","url":"https://nmayorov.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nmayorov.github.io/ accesskey=h title="Navigating Uncertainty (Alt + H)">Navigating Uncertainty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://nmayorov.github.io/archives title="All posts"><span>All posts</span></a></li><li><a href=https://nmayorov.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://nmayorov.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://nmayorov.github.io/posts/>Posts</a></div><h1 class=post-title>Implementation of Kalman correction formulas</h1><div class=post-meta><span title='2023-01-12 00:00:00 +0000 UTC'>January 12, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Nikolay Mayorov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#basic-formulas aria-label="Basic formulas">Basic formulas</a><ul><li><a href=#scalar-measurement aria-label="Scalar measurement">Scalar measurement</a></li></ul></li><li><a href=#independent-measurements-and-sequential-updates aria-label="Independent measurements and sequential updates">Independent measurements and sequential updates</a></li><li><a href=#measurements-with-diagonal-r aria-label="Measurements with diagonal $R$">Measurements with diagonal $R$</a></li><li><a href=#measurements-with-non-diagonal-r aria-label="Measurements with non-diagonal $R$">Measurements with non-diagonal $R$</a></li><li><a href=#overall-algorithm aria-label="Overall algorithm">Overall algorithm</a></li></ul></div></details></div><div class=post-content><p>This is a short note on my view how to best implement Kalman correction formulas in a programing language.</p><h1 id=basic-formulas>Basic formulas<a hidden class=anchor aria-hidden=true href=#basic-formulas>#</a></h1><p>A vector measurement is linearly related to a state vector with an additive noise:
$$
z = H x + v
$$
Where $z$ and $H$ are a known vector and matrix and the noise vector $v$ has a known covariance matrix $R$.
Thus the measurement model is defined by 3 elements &ndash; $z, H, R$.</p><p>The measurement is processed to improve the state estimate and reduce its error variance according to formulas:
$$
x^+ = x^- + K (z - H x^-) \\
P^+ = (I - KH) P^- \\
\text{with } K = P^- H^T S^{-1} \text{ and } S = H P^- H^T + R
$$
Where $x^-, P^-$ and $x^+, P^+$ are state estimates and error covariance matrices before (aprior) and after (aposteriori) the measurement was processed respectively.
The gain vector $K$ optimally combines the apriori estimate and the measurement to achieve the smallest error variance of the $x^+$.</p><p>The formulas are valid as long as the innovation covariance matrix $S$ is positive definite, which makes them almost universally applicable in practical problems.</p><h2 id=scalar-measurement>Scalar measurement<a hidden class=anchor aria-hidden=true href=#scalar-measurement>#</a></h2><p>If $z$ contains only a single element we can consider it to be a scalar and write the measurement equation as
$$
z = h^T x + v
$$
Let $r$ be the variance of the scalar noise $v$.</p><p>The correction formulas are more simple and elegant in this case:
$$
x^+ = x^- + (z - h^T x^-) k \\
P^+ = P^- - s k k^T \\
\text{with } k = P^- h / s \space \text{ and } \space s = h^T P^- h + r
$$
Its free from the matrix inversion as we have the scalar innovation variance $s$.</p><p>The covariance formula has a nice symmetric rank-1 update form.
This operation is known as <code>SYR</code> BLAS subroutine.
For example in Eigen C++ library it is provided by the method <code>SelfAdjointView::rankUpdate</code>.
It is recommended to use a similar method of function in your implementation if possible.</p><h1 id=independent-measurements-and-sequential-updates>Independent measurements and sequential updates<a hidden class=anchor aria-hidden=true href=#independent-measurements-and-sequential-updates>#</a></h1><p>Consider a measurement vector composed of two independent (uncorrelated) blocks:
$$
z = \begin{bmatrix} z_1 \\ z_2 \end{bmatrix} \\
H = \begin{bmatrix} H_1 \\ H_2 \end{bmatrix} \\
R = \begin{bmatrix} R_1 & 0 \\ 0 & R_2 \end{bmatrix}
$$
The matrix $R$ is block diagonal which represents the aforementioned independence.</p><p>From probabilistic and logical reasoning we can conclude that processing measurement $z$ is equivalent to processing measurements $z_1$ and $z_2$ sequentially in any order.
Surprisingly it&rsquo;s hard to prove that using formal matrix transformations of the correction formulas.
I haven&rsquo;t been able to find a simple approach to that.</p><p>A proof can be given using the equivalent &#171;inverse covariance&#187; form of the correction formulas:
$$
(P^+)^{-1} x^+ = (P^-)^{-1} x^- + H^T R^{-1} z \\
(P^+)^{-1} = (P^-)^{-1} + H^T R^{-1} H
$$
They are more restrictive compared to the standard formulas as requiring positive definite $P$ and $R$ matrices.</p><p>Substituting the composed measurement matrices into it we get
$$
(P^+)^{-1} x^+ = (P^-)^{-1} x^- + H_1^T R_1^{-1} z_1 + H_2^T R_2^{-1} z_2 \\
(P^+)^{-1} = (P^-)^{-1} + H_1^T R_1^{-1} H_1 + H_2^T R_2^{-1} H_2
$$
We see that these formulas are additive in the measurement blocks and thus the sequential processing is correct.</p><p>If $R$ and $P$ are not positive definite we can consider an artificial positive diagonal regularization, do the sequential processing in the standard form and then set the regularization to zero (in a limit sense).
This is an informal proof that the sequential processing is correct as long as the standard formulas are applicable.</p><h1 id=measurements-with-diagonal-r>Measurements with diagonal $R$<a hidden class=anchor aria-hidden=true href=#measurements-with-diagonal-r>#</a></h1><p>If the matrix $R$ is diagonal then all individual measurement components are independent.
Such measurement are processed as a sequence of scalar measurements $z_i, h_i, r_i$ with
$$
h_i = (H_{i, :})^T \\
r_i = R_{i, i}
$$
where $H_{i, :}$ is the $i$-th row of $H$.</p><h1 id=measurements-with-non-diagonal-r>Measurements with non-diagonal $R$<a hidden class=anchor aria-hidden=true href=#measurements-with-non-diagonal-r>#</a></h1><p>We can apply the sequential measurement processing in this case too by introducing an augmented vector:
$$
x_a = \begin{bmatrix}
x \\
v
\end{bmatrix}
$$</p><p>The apriori state estimate and covariance matrix for the augmented vector are:
$$
x_a^- = \begin{bmatrix}
x^- \\
0
\end{bmatrix} \\
P_a^- = \begin{bmatrix}
P^- & 0 \\
0 & R
\end{bmatrix}
$$</p><p>The measurement in terms of the augmented vector:
$$
z = H x + v = H_a x_a + v_a \\
\text{with } H_a = \begin{bmatrix}
H & I
\end{bmatrix}
$$
The dummy noise vector $v_a$ has zero covariance matrix $R_a = 0$.</p><p>Then the augmented measurement model $z, H_a, R_a$ is processed for $x_a^-, P_a^-$ using the sequential approach to get $x_a^+, P_a^+$.
The head of $x_a^+$ and the top-left corner of $P_a^+$ contain the required aposteriori $x^+$ and $P^+$.</p><h1 id=overall-algorithm>Overall algorithm<a hidden class=anchor aria-hidden=true href=#overall-algorithm>#</a></h1><p>The following algorithm can be used to process an arbitrary measurement model $z, H, R$:</p><ol><li>If $R$ is diagonal: apply the sequential processing to the original model</li><li>If $R$ is not diagonal: build the augmented model and apply the sequential processing to it</li></ol><p>The core algorithm in both cases is the scalar measurement processing described above, which is easy to implement and robust.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://nmayorov.github.io/>Navigating Uncertainty</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>